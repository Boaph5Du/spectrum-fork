Spectrum is an open-membership protocol, thus, PBFTNetwork's assumption on a closed consensus group is nod valid.
Sybil attacks cat break any protocol with security thresholds such as PBFT's assumption that at most $f$ out of\
${3 f + 1}$ members are honest, thus, an appropriate dynamic selection of opening consensus group is crucial for\
network livness and safety.
Consensus group members selection should be performed in a random and trusted way to ensure that a sufficient fraction\
of the selected members are honest, selection procedure should be independent of any internal or external advisers.

Bitcoin~\cite{nakamoto2009bitcoin} and many of its successors are using proof-of-work (PoW) consensus.
In essence, PoW in Bitcoin is a robust mechanism that facilitates randomized selection of a \enquote{leader} that is\
eligible to produce a new block.
Later, PoW approach was adapted into a proof-of-membership mechanism by ~\cite{kokoriskogias2016enhancing}\
to select a new consensus group once in a while, which then executes the PBFT consensus protocol.
A primary consideration regarding PoW is the amount of energy required for the systems that operate on it and
a natural alternative to PoW is a mechanism that relies on the concept of proof-of-stake (PoS).
Rather than investing computational resources in order to participate in the leader election process,\
participants of a PoS system instead run a process that randomly selects one of them proportionally to the stake.
Pure PoS mechanism to solve the PBFT problem was firstly used in ~\cite{cryptoeprint:2017/454} to select both consensus\
group members and PBFT rounds leaders.
To introduce randomness into these processes, Verifiable Random Function (VRF) has been applied.

\subsubsection{Verifiable Random Function}

Verifiable Random Function (VRF) is a reliable way to introduce randomness in the protocol and to be\
used as a random oracle.
By definition the function $\mathcal{F}$ can be attributed to the VRF family if the following methods are defined\
for the $\mathcal{F}$:
\begin{enumerate}
    \item \textbf{Gen}: ${Gen(1^k) \rightarrow (pk, sk)}$, where $pk$ is the public key and $sk$ is the secret key;
    \item \textbf{Prove}: ${Prove(x; sk) \rightarrow (\mathcal{F}(x; sk), \pi)}$, where $x$ is a random input, $\mathcal{F}(x; sk)$\
    is a random value, sampled from $\{0,1\}^{l_{VRF}}$ and $\pi \vcentcolon= \pi(x; sk)$ is the associated proof;
    \item \textbf{Verify}: ${Verify(x, y, \pi; pk) \rightarrow 0 | 1}$, where the output is $1$ if\
    and only if ${y=\mathcal{F}(x; sk)}$.
\end{enumerate}

There are several ways to design a VRF appropriate for our purposes.
At the first stage of the Spectrum protocol development we'll use an implementation, inspired\
by~\cite{cryptoeprint:2017/573}, which is based on the 2-Hash-DH verifiable oblivious PRF~\cite{asiacrypt:2014/233}.

This implementation is based on the hash functions $H$ and $H'$  with ranges $\{0,1\}^{l_{VRF}}$ and ${\langle g \rangle}$\
respectively, where ${\langle g \rangle = q}$.
Thereby, public key and the private key received from the \textbf{Gen}\
output is ${pk = g \cdot k}$ and ${sk = H'(x) \cdot k}$ respectively.
\textbf{Prove} method returns the VRF generated random value ${y = H(x, sk)}$ and the proof\
${\pi = (sk, EQDL(k : \log_{H'(x)}(sk) = \log_{g}(pk); x, pk))}$.
The \textbf{Verify} of ${(x, y, \pi, pk)}$ at first parses $\pi$ as ${(pk, \pi')}$ where $\pi'$ is a proof of equality of\
discrete logarithms and then verifies ${y = H(x, sk)}$ with the proof $\pi'$.
Finally, it returns $1$ if and only if both tests pass.
The proof notation ${EQDL(k : \log_{H'(x)}(sk) = \log_{g}(pk); x, pk)}$ stands for the string ${(c, s)}$\
where $c = H(x, pk, g \cdot r, H'(x) \cdot r)$, ${s = r + k \cdot c}$ mod $q$, while the verification of ${(c, s)}$ on\
context ${x, pk}$ is performed by checking the equality ${c = H(x, pk, g^s \cdot pk^{-c}, H'(x)^s \cdot sk^{-c})}$.

\subsubsection{Lottery protocol}
Our lottery protocol is designed to achieve 2 main purposes:
\begin{itemize}
    \item Consensus group reinitialization.
    \item Slot leaders selection.
\end{itemize}

Let's look at the lottery protocol integrated into the normal protocol flow.
There are some pre-defined primitives, detailed description of which can be found in the original\
Ouroboros Praos paper ~\cite{cryptoeprint:2017/573}.
\begin{enumerate}
    \item \textbf{Ideal Resettable Leaky Beacon} ${\mathcal_{F}}_{RLB}$: is used to sample epoch randomness from the\
    blockchain.
    \item \textbf{Ideal Verifiable Random Function} ${\mathcal_{F}}_{VRF}$: generates random numbers with proofs.
    \item \textbf{Lottery function} ${\mathcal_{F}}_{L}$: determines whether a participant is a winner based on a\
    random number and other parameters.
\end{enumerate}
Protocol initially is running by manually selected opening consensus group $\{PK_i\}_{i=0}^M$ of the predefined size $M$.
Stakeholders interact with each other and with the ideal functionalities ${\mathcal_{F}}_{RLB}$,\
${\mathcal_{F}}_{VRF}, {\mathcal_{F}}_{L}$ over a sequence of $L = E \cdot R$ slots\
${S=\{sl_1,...,sl_L\}}$ consisting of $E$ epochs with $R$ slots each.

\textbf{Lottery function}
The lottery function ${\mathcal_{F}}_{L}$ compares the random number $y$ generated by the ${\mathcal_{F}}_{VRF}$ with\
a threshold value $T$ and evaluates to $1$ if and only if ${y < T}$, i.e.\
${\mathcal_{F}}_{L}(state, f, y) \rightarrow 0|1$, where $state$ is a blockchain state snapshot, $f$\
is a frequency parameter.
An important feature is that the probability $p$ that the described condition will be met depends on the stake\
$s$ of the participant and can be adjusted by a free parameter $f$.
Threshold value is calculated according to ${T = 2^{l_{VRF}}\cdot \phi(\alpha, f)}$, where\
${\alpha=s/\\\sum_{l=0}^{l=M} s_l}$ is a relative stake of the participant.
Thus, probability of winning is ${p = \phi(\alpha, f) = 1-(1-f)^{\alpha}}$.

\textbf{Consensus group reinitialization}.
Every new epoch has a new consensus group and any protocol participant can try to become a member of the new consensus\
group if he is verified.
Participant is verified if his verification key tuple is stored in the blockchain for a\
reliable period of time equals to $K_F$ slots.

At the end of the epoch ${e_j \geqslant 1}$ every verified $PK_i$ sends\
${(\textbf{epochrnd\_req}, sid, PK_i, e_j)}$ to ${\mathcal_{F}}_{RLB}$ and receives\
$({\textbf{epochrnd}, sid, \eta_j)}$.
When every $PK_i$ evaluates ${\mathcal_{F}}_{VRF}$ with a query\
${(\textbf{EvalProve}, sid, \eta_j || e_j || \textbf{test*})}$\
and pass the received random $y$ value to the ${\mathcal_{F}}_{L}$.
To calculate an appropriate threshold ${T_i^j}^*$, ${\mathcal_{F}}_{L}$ should be parametrized with the same\
stake distribution which was in the last block used by ${\mathcal_{F}}_{RLB}$ to sample a new $\eta_j$.
Argument of the function $\phi$ is ${f = M /\/ K}$, where $M$ is a number of new consensus group\
members to select and $K$ is the total number of the verified stakeholders.
Afterwards every selected consensus group member includes the associated proofs into the blockchain.

\textbf{Slot leaders}.
During the epoch, for every slot ${sl \in S}$ every consensus group member separately evaluates\
${\mathcal_{F}}_{VRF}$ with his own inputs ${(\textbf{EvalProve}, sid, \eta_j || sl || \textbf{nonce})}$\
and ${(\textbf{EvalProve}, sid, \eta_j || sl || \textbf{test})}$, where \textbf{nonce} is an arbitrary string.
Received outputs ${(\textbf{Evaluated}, sid, y, \pi)}$ and ${(\textbf{Evaluated}, sid, \rho_y, \rho_\pi)}$\
respectively includes generated random numbers ${y, \rho_y}$ and the associated proofs ${\pi, \rho_\pi}$.

If ${\mathcal_{F}}_{L}(state, f, y) \rightarrow 1$ then $PK_i$ is a slot leader and he can propose a batch\
which should be notarized by all committee members.
Random number $\rho_y$ will be used to sample a random seed for the next epoch.
At every slot $PK_i$ can be chosen as the slot leader with the probability
${p_i = \phi(\alpha_i, f) = 1-(1-f)^{\alpha_i}}$, where ${\alpha_i=s_i/\\\sum_{l=0}^{l=M} s_l}$ is a relative stake\
of the participant, fixed at the moment of the epoch $e_j$ start.
Parameter $f$ is an active slots coefficient, responsible for percentage of slots in the epoch which should have\
at least one leader.
In other words, it determines how many slots will pass before a new block is produced.

Using the scheme above we force opening consensus group members and slot leaders aren't publicly known ahead of time.
An attacker can't see who was a slot leader until he initializes batch notarization, thus an attacker can't know
who specifically to attack in order to control a certain slot ahead of time.
Grinding attacks are also limited because an adversary can't arbitrarily control $\eta_j$ values.
All he can try to do is to make as many forks as possible to estimate the most advantageous, but according to the\
analysis this advantage doesn't change the security properties of the entire protocol.

Using VRF is also cheap and fast, only initialization requires ${O(n^2)}$ communication between all participants\
to agree on a genesis block.
Single VRF evaluation is approximately 100 microseconds on x86-64 for a specific curves used in hash functions.
There is also great UC-extension for batch verification\
proposed by ~\cite{cryptoeprint:2022/1045} which make it even faster.