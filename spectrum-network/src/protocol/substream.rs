use crate::types::RawMessage;
use asynchronous_codec::Framed;
use futures::{AsyncRead, AsyncWrite, Sink, Stream};
use std::convert::Infallible;
use std::io;
use std::pin::Pin;
use std::task::{Context, Poll};
use unsigned_varint::codec::UviBytes;

/// State of the handshake sending back process.
pub enum ProtocolSubstreamHandshakeState {
    /// Waiting for the user to give us the handshake message.
    NotSent,
    /// Initial handshake not required.
    NotRequired,
    /// User gave us the handshake message. Trying to push it in the socket.
    PendingSend(RawMessage),
    /// Handshake message was pushed in the socket. Still need to flush.
    Flush,
    /// Handshake message successfully sent and flushed.
    Sent,
    /// Remote has closed their writing side. We close our own writing side in return.
    ClosingInResponseToRemote,
    /// Both our side and the remote have closed their writing side.
    BothSidesClosed,
}

/// Error generated by sending on a notifications out substream.
#[derive(Debug, thiserror::Error)]
pub enum ProtocolSubstreamOutError {
    /// I/O error on the substream.
    #[error(transparent)]
    Io(#[from] io::Error),
}

/// A substream for incoming messages.
///
/// When creating, this struct starts in a state in which we must first send back a handshake
/// message to the peer. No message will come before this has been done.
#[pin_project::pin_project]
pub struct ProtocolSubstreamIn<Substream> {
    #[pin]
    pub socket: Framed<Substream, UviBytes<io::Cursor<Vec<u8>>>>,
    pub handshake_state: ProtocolSubstreamHandshakeState,
}

impl<Substream> ProtocolSubstreamIn<Substream> {
    pub fn send_handshake(&mut self, hanshake: RawMessage) {
        if matches!(
            self.handshake_state,
            ProtocolSubstreamHandshakeState::NotSent
        ) {
            self.handshake_state = ProtocolSubstreamHandshakeState::PendingSend(hanshake);
        }
    }

    /// Equivalent to `Stream::poll_next`, except that it only drives the handshake and is
    /// guaranteed to not generate any notification.
    pub fn poll_process_handshake(
        self: Pin<&mut Self>,
        cx: &mut Context,
    ) -> Poll<Result<Infallible, io::Error>> {
        todo!()
    }
}

impl<Substream> Stream for ProtocolSubstreamIn<Substream> {
    type Item = Result<RawMessage, io::Error>;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        todo!()
    }
}

/// A substream for outgoing notification messages.
#[pin_project::pin_project]
pub struct ProtocolSubstreamOut<Substream> {
    /// Substream where to send messages.
    #[pin]
    pub socket: Framed<Substream, UviBytes<io::Cursor<Vec<u8>>>>,
}

impl<Substream> Sink<RawMessage> for ProtocolSubstreamOut<Substream>
where
    Substream: AsyncRead + AsyncWrite + Unpin,
{
    type Error = ProtocolSubstreamOutError;

    fn poll_ready(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Result<(), Self::Error>> {
        let mut this = self.project();
        Sink::poll_ready(this.socket.as_mut(), cx).map_err(ProtocolSubstreamOutError::Io)
    }

    fn start_send(self: Pin<&mut Self>, item: RawMessage) -> Result<(), Self::Error> {
        let mut this = self.project();
        Sink::start_send(this.socket.as_mut(), io::Cursor::new(item.into()))
            .map_err(ProtocolSubstreamOutError::Io)
    }

    fn poll_flush(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Result<(), Self::Error>> {
        let mut this = self.project();
        Sink::poll_flush(this.socket.as_mut(), cx).map_err(ProtocolSubstreamOutError::Io)
    }

    fn poll_close(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Result<(), Self::Error>> {
        let mut this = self.project();
        Sink::poll_close(this.socket.as_mut(), cx).map_err(ProtocolSubstreamOutError::Io)
    }
}
